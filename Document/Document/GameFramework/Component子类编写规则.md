# Space Game Engine Document
## `Component`子类编写规则

> 本文档不是讲如何写`Component`子类的，欲了解`Component`子类编写的一些基本要求，请查看[Space基本组件Component类](./Space基本组件Component类.md)

### 规则1

#### 为什么要有这个规则？
&emsp;&emsp;这个`Component`子类编写规则是为了解决**不同的游戏对象(`Oobject`)之间实际是按照顺序运行的而导致的一系列问题**。例如：如果我在一个组件里修改了另一个对象里的`Transform`组件的数据，但是那个对象已经运行过了，所以其如果有网格(`Mesh`)的话，那么其`Mesh`的AABB盒却没有对这个更改进行反应（因为重算AABB是在`Mesh`的`Run`方法中进行的，而其已被运行过，在当前循环中不会再运行第二次了），就会出错。

&emsp;&emsp;在编写组件代码时，如果能遵守这些规则，就能减少甚至避免这类问题的发生。

#### 内容

* `Component`最好只读写自身的数据。
* `Component::Run`代表着由上一帧的状态计算出这一帧的状态的过程。
* 需求关系分析
  1. 如果是读取同一对象内的其他组件的数据，则要将该组件链接在其的下面。
  2. 如果是修改同一对象内的其他组件的数据，则要将要修改的组件链在该组件的下面。
  3. 如果是读取另一对象的组件的数据，则要在组件中`Require`这个要读取的对象。
  4. 如果是修改另一对象的组件的数据，则要使这个被修改的对象`Require`这个修改它的组件所在的对象。
  > 不能循环`Require`。  
  > `Require`一个`Object`，就相当于`Require`这个`Object`的父对象。`Unrequire`同理。  
  > 如果是父子关系的组件，子对象相当于都`Require`父对象。不需要再`Require`。
* 如果需求关系出现环，或是执行顺序有冲突,则出现冲突的数据应使用`DoubleBuffer`模板来进行管理,不再需要`Require`。

### 规则2

#### 内容
* `InitFromFile`方法中**必须将`mode`形参赋值给`m_Mode`成员**
* `InitFromFile`方法应保证其行为只是修改组件自身的数据。